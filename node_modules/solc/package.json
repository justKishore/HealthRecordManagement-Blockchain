{
  "_from": "solc",
  "_id": "solc@0.5.7",
  "_inBundle": false,
  "_integrity": "sha512-DaYFzB3AAYjzPtgUl9LenPY2xjI3wG9k8U8T8YE/sXHVIoCirCY5MB6mhcFPgk/VyUtaWZPUCWiYS1E6RSiiqw==",
  "_location": "/solc",
  "_phantomChildren": {
    "decamelize": "1.2.0",
    "execa": "0.7.0",
    "get-caller-file": "1.0.3",
    "graceful-fs": "4.1.15",
    "klaw": "1.3.1",
    "lcid": "1.0.0",
    "locate-path": "2.0.0",
    "mem": "1.1.0",
    "path-is-absolute": "1.0.1",
    "require-directory": "2.1.1",
    "require-main-filename": "1.0.1",
    "rimraf": "2.6.3",
    "set-blocking": "2.0.0",
    "wrap-ansi": "2.1.0",
    "y18n": "3.2.1"
  },
  "_requested": {
    "escapedName": "solc",
    "fetchSpec": "latest",
    "name": "solc",
    "raw": "solc",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/solc/-/solc-0.5.7.tgz",
  "_shasum": "d84697ac5cc63d9b2139bfb349cec64b64861cdc",
  "_spec": "solc",
  "_where": "/home/faizan/Documents/blockchain/project/record-management/static/js",
  "author": {
    "name": "chriseth"
  },
  "bin": {
    "solcjs": "solcjs"
  },
  "bugs": {
    "url": "https://github.com/ethereum/solc-js/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "command-exists": "^1.2.8",
    "fs-extra": "^0.30.0",
    "keccak": "^1.0.2",
    "memorystream": "^0.3.1",
    "require-from-string": "^2.0.0",
    "semver": "^5.5.0",
    "tmp": "0.0.33",
    "yargs": "^11.0.0"
  },
  "deprecated": false,
  "description": "Solidity compiler",
  "devDependencies": {
    "coveralls": "^3.0.0",
    "ethereumjs-util": "^5.2.0",
    "istanbul": "^0.4.5",
    "semistandard": "^12.0.0",
    "tape": "=4.9.2",
    "tape-spawn": "^1.4.2"
  },
  "files": [
    "abi.js",
    "index.js",
    "linker.js",
    "smtchecker.js",
    "smtsolver.js",
    "solcjs",
    "soljson.js",
    "translate.js",
    "wrapper.js"
  ],
  "homepage": "https://github.com/ethereum/solc-js#readme",
  "keywords": [
    "compiler",
    "ethereum",
    "solidity"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "solc",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://img.shields.io/travis/ethereum/solc-js.svg?branch=master&style=flat-square)](https://travis-ci.org/ethereum/solc-js)\n[![CircleCI](https://img.shields.io/circleci/project/github/ethereum/solc-js/master.svg?style=flat-square)](https://circleci.com/gh/ethereum/solc-js/tree/master)\n[![Coverage Status](https://img.shields.io/coveralls/ethereum/solc-js.svg?style=flat-square)](https://coveralls.io/r/ethereum/solc-js)\n\n# solc-js\nJavaScript bindings for the [Solidity compiler](https://github.com/ethereum/solidity).\n\nUses the Emscripten compiled Solidity found in the [solc-bin repository](https://github.com/ethereum/solc-bin).\n\n## Node.js Usage\n\nTo use the latest stable version of the Solidity compiler via Node.js you can install it via npm:\n\n```bash\nnpm install solc\n```\n\n### Usage on the Command-Line\n\nIf this package is installed globally (`npm install -g solc`), a command-line tool called `solcjs` will be available.\n\nTo see all the supported features, execute:\n\n```bash\nsolcjs --help\n```\n\nNote: this commandline interface is not compatible with `solc` provided by the Solidity compiler package and thus cannot be\nused in combination with an Ethereum client via the `eth.compile.solidity()` RPC method. Please refer to the\n[Solidity compiler documentation](https://solidity.readthedocs.io/) for instructions to install `solc`.\n\n### Usage in Projects\n\nThere are two ways to use `solc`:\n1) Through a high-level API giving a uniform interface to all compiler versions\n2) Through a low-level API giving access to all the compiler interfaces, which depend on the version of the compiler\n\n#### High-level API\n\nThe high-level API consists of a single method, `compile`, which expects the [Compiler Standard Input and Output JSON](https://solidity.readthedocs.io/en/v0.5.0/using-the-compiler.html#compiler-input-and-output-json-description).\n\nIt also accepts an optional callback function to resolve unmet dependencies. This callback receives a path and must synchronously return either an error or the content of the dependency as a string.\nIt cannot be used together with callback-based, asynchronous, filesystem access. A workaround is to collect the names of dependencies, return an error, and keep re-running the compiler until all\nof them are resolved.\n\n*Note*: as an intermittent backwards compatibility feature, between versions 0.5.0 and 0.5.2, `compileStandard` and `compileStandardWrapper` also exists and behave like `compile` does.\n\n#### Example usage without the import callback\n\nExample:\n```javascript\nvar solc = require('solc')\n\nvar input = {\n\tlanguage: 'Solidity',\n\tsources: {\n\t\t'test.sol': {\n\t\t\tcontent: 'contract C { function f() public { } }'\n\t\t}\n\t},\n\tsettings: {\n\t\toutputSelection: {\n\t\t\t'*': {\n\t\t\t\t'*': [ '*' ]\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar output = JSON.parse(solc.compile(JSON.stringify(input)))\n\n// `output` here contains the JSON output as specified in the documentation\nfor (var contractName in output.contracts['test.sol']) {\n\tconsole.log(contractName + ': ' + output.contracts['test.sol'][contractName].evm.bytecode.object)\n}\n```\n\n#### Example usage with import callback\n\n```javascript\nvar solc = require('solc')\n\nvar input = {\n\tlanguage: 'Solidity',\n\tsources: {\n\t\t'test.sol': {\n\t\t\tcontent: 'import \"lib.sol\"; contract C { function f() public { L.f(); } }'\n\t\t}\n\t},\n\tsettings: {\n\t\toutputSelection: {\n\t\t\t'*': {\n\t\t\t\t'*': [ '*' ]\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction findImports (path) {\n\tif (path === 'lib.sol')\n\t\treturn { contents: 'library L { function f() internal returns (uint) { return 7; } }' }\n\telse\n\t\treturn { error: 'File not found' }\n}\n\nvar output = JSON.parse(solc.compile(JSON.stringify(input), findImports))\n\n// `output` here contains the JSON output as specified in the documentation\nfor (var contractName in output.contracts['test.sol']) {\n\tconsole.log(contractName + ': ' + output.contracts['test.sol'][contractName].evm.bytecode.object)\n}\n```\n\n#### Low-level API\n\nThe low-level API is as follows:\n- `solc.lowlevel.compileSingle`: the original entry point, supports only a single file\n- `solc.lowlevel.compileMulti`: this supports multiple files, introduced in 0.1.6\n- `solc.lowlevel.compileCallback`: this supports callbacks, introduced in 0.2.1\n- `solc.lowlevel.compileStandard`: this works just like `compile` above, but is only present in compilers after (and including) 0.4.11\n\nFor examples how to use them, please refer to the README of the above mentioned solc-js releases.\n\n### Using with Electron\n\n**Note:**\nIf you are using Electron, `nodeIntegration` is on for `BrowserWindow` by default. If it is on, Electron will provide a `require` method which will not behave as expected and this may cause calls, such as `require('solc')`, to fail.\n\nTo turn off `nodeIntegration`, use the following:\n\n```javascript\nnew BrowserWindow({\n\twebPreferences: {\n\t\tnodeIntegration: false\n\t}\n})\n```\n\n### Using a Legacy Version\n\nIn order to compile contracts using a specific version of Solidity, the `solc.loadRemoteVersion(version, callback)` method is available. This returns a new `solc` object that uses a version of the compiler specified. \n\nYou can also load the \"binary\" manually and use `setupMethods` to create the familiar wrapper functions described above:\n`var solc = solc.setupMethods(require(\"/my/local/soljson.js\"))`.\n\n### Using the Latest Development Snapshot\n\nBy default, the npm version is only created for releases. This prevents people from deploying contracts with non-release versions because they are less stable and harder to verify. If you would like to use the latest development snapshot (at your own risk!), you may use the following example code.\n\n```javascript\nvar solc = require('solc')\n\n// getting the development snapshot\nsolc.loadRemoteVersion('latest', function (err, solcSnapshot) {\n\tif (err) {\n\t\t// An error was encountered, display and quit\n\t} else {\n\t\t// NOTE: Use `solcSnapshot` here with the same interface `solc` has\n\t}\n})\n```\n\n### Linking Bytecode\n\nWhen using libraries, the resulting bytecode will contain placeholders for the real addresses of the referenced libraries. These have to be updated, via a process called linking, before deploying the contract.\n\nThe `linker` module (`require('solc/linker')`) offers helpers to accomplish this.\n\nThe `linkBytecode` method provides a simple helper for linking:\n\n```javascript\nvar linker = require('solc/linker')\n\nbytecode = linker.linkBytecode(bytecode, { 'MyLibrary': '0x123456...' })\n```\n\nAs of Solidity 0.4.11 the compiler supports [standard JSON input and output](https://solidity.readthedocs.io/en/develop/using-the-compiler.html#compiler-input-and-output-json-description) which outputs a *link references* map. This gives a map of library names to offsets in the bytecode to replace the addresses at. It also doesn't have the limitation on library file and contract name lengths.\n\nThere is a method available in the `linker` module called `findLinkReferences` which can find such link references in bytecode produced by an older compiler:\n\n```javascript\nvar linker = require('solc/linker')\n\nvar linkReferences = linker.findLinkReferences(bytecode)\n```\n\n### Updating the ABI\n\nThe ABI generated by Solidity versions can differ slightly, due to new features introduced.  There is a tool included which aims to translate the ABI generated by an older Solidity version to conform to the latest standard.\n\nIt can be used as:\n```javascript\nvar abi = require('solc/abi')\n\nvar inputABI = [{\"constant\":false,\"inputs\":[],\"name\":\"hello\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"}]\nvar outputABI = abi.update('0.3.6', inputABI)\n// Output contains: [{\"constant\":false,\"inputs\":[],\"name\":\"hello\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":true,\"type\":\"function\"},{\"type\":\"fallback\",\"payable\":true}]\n\n```\n\n### Formatting old JSON assembly output\n\nThere is a helper available to format old JSON assembly output into a text familiar to earlier users of Remix IDE.\n\n```\nvar translate = require('solc/translate')\n\n// assemblyJSON refers to the JSON of the given assembly and sourceCode is the source of which the assembly was generated from\nvar output = translate.prettyPrintLegacyAssemblyJSON(assemblyJSON, sourceCode)\n```\n\n## Browser Usage\n\nAdd the version of `solc` you want to use into `index.html`:\n\n```html\n<script type=\"text/javascript\" src=\"https://solc-bin.ethereum.org/bin/{{ SOLC VERSION }}.js\"></script>\n```\n\n(Alternatively use `https://solc-bin.ethereum.org/bin/soljson-latest.js` to get the latests version.)\n\nThis will load `solc` into the global variable `window.Module`. Then use this inside Javascript as:\n\n```javascript\nvar wrapper = require('solc/wrapper')\nvar solc = wrapper(window.Module)\n\n```\n\nOr in ES6 syntax:\n```javascript\nimport * as wrapper from 'solc/wrapper'\nconst solc = wrapper(window.Module)\n```\n\nAlternatively, to iterate the releases, one can load `list.js` from `solc-bin`:\n```html\n<script type=\"text/javascript\" src=\"https://solc-bin.ethereum.org/bin/list.js\"></script>\n```\n\nThis will result in two global variables, `window.soljsonReleases` listing all releases and `window.soljsonSources` listing all nightly builds and releases.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ethereum/solc-js.git"
  },
  "scripts": {
    "coverage": "istanbul cover node_modules/tape/bin/tape ./test/index.js",
    "coveralls": "npm run coverage && coveralls <coverage/lcov.info",
    "lint": "semistandard",
    "prepublish": "node downloadCurrentVersion.js && node verifyVersion.js",
    "pretest": "npm run lint",
    "test": "tape ./test/index.js"
  },
  "semistandard": {
    "ignore": [
      "soljson.js"
    ]
  },
  "version": "0.5.7"
}
